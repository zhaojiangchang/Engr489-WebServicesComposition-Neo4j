\chapter{The Graph database-based Approach}\label{C:wd}
This report focuses on the the use of graph databases to model a service repository, with dependencies between the Web services and corresponding compositions being stored in Neo4j graph databases. In the rest of this chapter, we will describe several new methods and show the results of those methods.\par
Our graph based based approach consists of four steps:\par
\begin{enumerate}
  \item To create graph database for a web service repository
  \item To generate a graph database for a given task
  \item To generate initial population of service composition solutions
  \item To select a service composition solution from the population with the best overall QoS
\end{enumerate}

The overall design of our system is shown as Figure \ref{fig:process}. The sections following Figure \ref{fig:process} will introduce the design in detail.\par
\begin{figure}[H]
\includegraphics[width=9cm]{process.png}
\centering
\caption{Overall system design}
\label{fig:process} 
\end{figure} 

\section{Proposed Graph Databases} \label{procesedGD}
\subsubsection {Web Service Composition Modeling}
In this project we model a Web service as an entity which has a name, and has a set of properties \emph{name, id, qos, inputs, outputs, inputServices, and outputServices}. The first step is to model service repositories, which contains sets of services, that have dependency between each others. Each service takes inputs, produce outputs, and has QoS. In the following description of our approach we provide details of this model.\par
\subsubsection {Inputs and Outputs}
It is necessary to label each Web service to make it visually identifiable. The different \emph{inputs} and  \emph{outputs} of each Web service should also be easily identifiable, and with our approach we used a taxonomy tree. In the particular taxonomy tree we used, any two concepts \emph{A} and \emph{B} can be related to each other in one of four possible ways. The first scenario is that \emph{A} is a generalization of \emph{B}. The second scenario is that \emph{A} is a specialization of \emph{B}. The third scenario is that \emph{A} and \emph{B} are not related to each other. And the last scenario is that  \emph{A} equals \emph{B}. For example, the Web service \newcommand{\quotes}[1]{``#1''}\quotes{FindHotel} uses a single input parameter (cityName) represented by the concept of \quotes{CITY}, which belongs to the taxonomy tree. Therefore, \quotes{FindHotel} requires an instance of the concept \quotes{CITY}. The only output parameter (Hotel) is represented by an instance of the concept \quotes{Hotel} that also exists in the taxonomy tree. The \emph{inputs} and \emph{outputs} of each Web service are clearly defined in terms of concepts belonging to the specialized taxonomy tree.

\begin{algorithm}[H]
 \SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}

 \SetKwFunction{connectNode}{connectNode}\SetKwFunction{findCands}{findCands}\SetKwFunction{removeDangling}{removeDangling}
 \LinesNumbered
 \SetNlSty{}{}{:}
  \Input{$taxonomyNodes$, $serviceNodes$}
 \Output{$taxonomyNodes$}
 $i \leftarrow 0$\;
 \While{$i < |taxonomyNodes|$}{\label{buildingLine}
 $tNode \leftarrow taxonomyNodes[i]$\;
 $tNode.parents \leftarrow findParentsNodes(tNode)$\;
 $tNode.children \leftarrow findChildrenNodes(tNode)$\; 
 $i \leftarrow i+1$\;
 }
  $i \leftarrow 0$\;
  \While{$i < | serviceNodes |$}{\label{buildingLine}
       $j \leftarrow 0$\;
       $outputs \leftarrow serviceNodes[i].outputs$\;
      \While{$j < |outputs|$}{\label{buildingLine}
        $tNode \leftarrow findTaxonomyNode(outputs[j])$\;
        $k \leftarrow 0$\;
        \While{$j < |tNode.parents|$}{\label{buildingLine}
          $tNode.parents \leftarrow tNode.parents\cup \{serviceNodes[i]\}$\;
          $k \leftarrow k+1$\;
        }
         $j \leftarrow j+1$\;
      }
       $j \leftarrow 0$\;
       $inputs \leftarrow serviceNodes[i].inputs$\;
       \While{$j < |inputs|$}{\label{buildingLine}
        $tNode \leftarrow findTaxonomyNode(inputs[j])$\;
        $k \leftarrow 0$\;
        \While{$j < |tNode.children|$}{\label{buildingLine}
          $tNode.children \leftarrow tNode.children\cup \{serviceNodes[i]\}$\;
          $k \leftarrow k+1$\;
        }
         $j \leftarrow j+1$\;
      }
 $i \leftarrow i+1$\;
 }
 \caption{\footnotesize Populates the taxonomy tree by associating services with the nodes in the tree.}
\label{generation}
\end{algorithm}

\subsubsection {InputServices and OutputServices}
As shown in Figure \ref{fig:inputOutputServs}, within the Neo4j database, Web services are modelled as having a set of \emph{InputServices}, which is the set of Web services connected to the input side of the Web service, and  \emph{outputServices} which is the set of Web services connected to the output side of the service.\par
\begin{figure}[H]
\includegraphics[width=9cm]{InputServicesAndOutServices.png}
\centering
\caption{Input services and out services}
\label{fig:inputOutputServs} 
\end{figure} 
The reason that we added these two properties is to make it easier to retrieve the connected Web services and also to reduce the cost of creating relationships between Web services. Algorithm 1, which we designed for this project, identifies all the input and output services for each Web service using a taxonomy tree. \par
\begin{figure}[H]
\includegraphics[width=9cm]{Figure3-2-taxonomy-tree-example.png}
\centering
\caption{Taxonomy tree Example}
\label{fig:taxonomyTree} 
\end{figure} 
For example, Service \emph{1} has inputs \emph{I}$_1$ = \Big\{A\Big\} and outputs \emph{O}$_1$ = \Big\{B\Big\}, service \emph{2} has Inputs \emph{I}$_2$ = \Big\{E\Big\}  and outputs \emph{O}$_2$ = \Big\{B\Big\}, and service \emph{3} has Inputs \emph{I}$_3$ = \Big\{B\Big\}  and outputs \emph{O}$_3$ = \Big\{F\Big\}. Our algorithm 1 searches services inputs and outputs of services \emph{1, 2} and \emph{3}. Each value in inputs and outputs is a node in the taxonomy tree, which we call a taxonomy node (\emph{tNode}). Each \emph{tNode} has input services (\emph{IS}) and output services (\emph{OS}) fields; then we add Web services into corresponding \emph{IS} or \emph{OS} field. Taxonomy is represented as a tree, and each \emph{tNode} can have a parent node or child node.For example, \quotes{CITY} \emph{tNode} may have parent node called \quotes{COUNTRY} and child node called \quotes{HOTEL}. When we add Web service into \emph{IS}, we also add a Web service into all the \emph{tNode}'s parent node's \emph{IS} field. The same applies to adding Web service into \emph{OS}, in witch case we also add Web service into all the \emph{tNode}'s children node's \emph{OS} field. After we run the algorithm 1, we get \emph{IS}$_A$ = \Big\{service 1\Big\}, \emph{OS}$_A$ = \Big\{service 1, service 2, service 3\Big\}, \emph{IS}$_B$ = \Big\{service 1, service 3\Big\},\emph{OS}$_B$ = \Big\{service 1, service 2\Big\}, \emph{IS}$_E$ = \Big\{service 1, service 3\Big\}, \emph{OS}$_E$ = \Big\{Null\Big\}, \emph{IS}$_F$ = \Big\{service 1\Big\} and \emph{OS}$_F$ = \Big\{service 3\Big\} shown in Figure \ref{fig:taxonomyTree}. \par

Algorithm 2 goes through each input value in each Web service (\emph{WS}) in a service repository and finds a corresponding taxonomy node \emph{tNode} and then adds all the input services into the \emph{WS}'s \emph{InputServices} field. It also adds all the input services found in all parent taxonomy nodes into \emph{WS}'s \emph{IS} field. Additionally it checks each output value in each \emph{WS} in a repository, and finds corresponding \emph{tNode} , adding all the output services into the \emph{WS}'s \emph{OS} field, and all the output services found in all parent taxonomy nodes into \emph{WS}'s \emph{OS} field.

For example,  After we run the algorithm 2, we get: 
Service \emph{1} \emph{IS}$_1$ = \Big\{service 1, service 2, service 3\Big\},
Service \emph{1} \emph{OS}$_1$ = \Big\{service 1, service 3\Big\},
Service \emph{2} \emph{IS}$_2$ = \Big\{Null\Big\},
Service \emph{2} \emph{OS}$_2$ = \Big\{service 1, service 2\Big\},
Service \emph{3} \emph{IS}$_3$ = \Big\{service 1, service 2\Big\},
Service \emph{3} \emph{OS}$_3$ = \Big\{service 1\Big\}, shown in Figure \ref{fig:inputOutputServs}.\par

\begin{algorithm}[H]
 \SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
 \SetKwFunction{connectNode}{connectNode}\SetKwFunction{findCands}{findCands}\SetKwFunction{removeDangling}{removeDangling}
 \LinesNumbered
 \SetNlSty{}{}{:}
 \Input{$serviceNodes$}
 \Output{$serviceNodes$}
 $i \leftarrow 0$\;
 \While{$i < |serviceNodes|$}{\label{buildingLine}
   $sNode \leftarrow serviceNodes[i]$\;
   $sNode.inputServices \leftarrow \{\}$\;
   $sNode.outputServices \leftarrow \{\}$\;
   $j \leftarrow 0$\;
     \While{$j < |sNode.outputs|$}{\label{buildingLine}
        $tNode \leftarrow findTaxonomyNode(sNode.outputs[j])$\;
        $k \leftarrow 0$\;
      \While{$k < |tNode.outputServices|$}{\label{buildingLine}

          $sNode.outputServices \leftarrow sNode.outputServices\cup \{tNode.outputServices[k]\}$\;
          $k \leftarrow k+1$\;
      }
        $j \leftarrow j+1$\;
     }
      $j \leftarrow 0$\;
     \While{$j < |sNode.inputs|$}{\label{buildingLine}
        $tNode \leftarrow findTaxonomyNode(sNode.inputs[j])$\;
        $k \leftarrow 0$\;
      \While{$k < |tNode.inputServices|$}{\label{buildingLine}

          $sNode.inputServices \leftarrow sNode.inputServices\cup \{tNode.inputServices[k]\}$\;
          $k \leftarrow k+1$\;
      }
        $j \leftarrow j+1$\;
     }
   $i \leftarrow i+1$\;
 }
 
 \caption{\footnotesize add correspondence input services and output services to each Web service.}
\label{generation}
\end{algorithm}


\subsubsection {Web Service dependencies}
Each relationship is an directed edge that connects the output of a Web service node to the input of another node according to already established dependencies stored in the taxonomy tree. Like Web service nodes, relationships also have properties. They have a from node, a to node and direction. Relationships between Web service nodes are an essential part of a graph database. They allow us to find related Web services. In our project, we use relationships to solve composition problems. \par
Algorithm 3 handles the process of creating relationships between Web services. It goes through each Web service node \emph{N}, and loops through the corresponding \emph{inputServices} of each \emph{N}, and then add relationships between the Web services according to the sets of \emph{inputServices}.\\


\begin{algorithm}[H]
 \SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
 \SetKwFunction{connectNode}{connectNode}\SetKwFunction{findCands}{findCands}\SetKwFunction{removeDangling}{removeDangling}
 \LinesNumbered
 \SetNlSty{}{}{:}
 \Input{$serviceNodes$}
 \Output{$serviceNodes$}
 $i \leftarrow 0$\;
 \While{$i < |serviceNodes|$}{\label{buildingLine}
   $sNode \leftarrow serviceNodes[i]$\;
   $j \leftarrow 0$\;
     \While{$j < |sNode.inputServices|$}{\label{buildingLine}
      $inputSNode \leftarrow sNode.inputServices[j]$\;
      $relation \leftarrow inputSNode.createRelationshipTo(sNode)$\;
      $relation.setProperty("From" : inputsNode)$\;
      $relation.setProperty("To" : sNode)$\;
      $relation.setProperty("Outputs" : inputsNode.outputs)$\;
      $relation.setProperty("Direction" : incoming)$\;
        $j \leftarrow j+1$\;
      }
     $i \leftarrow i+1$\;
  }
 \caption{\footnotesize create relationships between Web services.}
\label{generation}
\end{algorithm}

Figure \ref{fig:beforeReduction} is an example of a graph database before reduction. The data set used in this example is WSC 2008 dataset 01, which contains is a total of 158 Web services. All the nodes represent the Web services and all the edges are the relationships between Web services. Once you click a node or an edge from the graph database, the properties of that node or edge appear at the bottom of the page. Figure \ref{fig:servProp} is an example of the properties that appear when you click the node Web service serv7231183. \par

\begin{figure}[H]
\includegraphics[width=9cm]{Graph-database-before-reduction.png}
\centering
\caption{Graph database before reduction (dataset01, WSC 2008)}
\label{fig:beforeReduction} 
\end{figure} 

\begin{figure}[H]
\includegraphics[width=9cm]{The-properties-of-Web-service-serv7231183.png}
\centering
\caption{The properties of Web service serv7231183 (dataset01, WSC 2008)}
\label{fig:servProp} 
\end{figure} 

\section{Reducing Graph Databases}
For each given task, only a subset of services in a repository are related to that task. Therefore we created a graph database for each given task. This section presents an algorithm that generates a reduced graph for a given task. \\

\begin{algorithm}[H]
 \SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
 \SetKwFunction{connectNode}{connectNode}\SetKwFunction{findCands}{findCands}\SetKwFunction{removeDangling}{removeDangling}
 \LinesNumbered
 \SetNlSty{}{}{:}
  \Input{$serviceNodes$}
 \Output{$relatedNodes$}
 $i \leftarrow 0$\;
 $relatedNodes \leftarrow \{\}$\;
 \While{$i < |serviceNodes|$}{\label{buildingLine}
   $sNode \leftarrow serviceNodes[i]$\;
   \If {$hasRelationship(sNode, startNode) \wedge hasRelationship(sNode, endNode)$}{\label{buildingLine}
        $relatedNodes \leftarrow relatedNodes\cup \{sNode\}$\;
   }
   \If {$!fulfillInputs(sNode)$}{\label{buildingLine}
      $removeRelatedNodes(sNode)$\;
   }
   $i \leftarrow i+1$\;
  }
  \Return { $relatedNodes $\;}
 \caption{\footnotesize reduce graph database.}
\label{generation}
\end{algorithm}
\par

Our algorithm first creates a start node \emph{S} and an end node \emph{E}. The start node \emph{S} contains the inputs of the task and the end node \emph{E}  contains the outputs of the task. Secondly, we insert these nodes into the database by creating new relationships between start node \emph{S} and all the nodes that use \emph{S}'s input. Similarly we create relationships between end node \emph{E} and all the nodes that can output data to node \emph{E}. Lastly, we find all services that lie on a path between \emph{S} and \emph{E} and remove all services that are not a path. Algorithm 4 shows the process of reducing the original graph database by removing all nodes which do not lie on a path between \emph{S} and \emph{E}.


The following example illustrates the effectiveness of our proposed algorithm.

Example: Applying our graph database reduction algorithm (Algorithm 4) to the graph database shown in Figure \ref{fig:inputOutputServs}, leads to the new reduced graph database shown in Figure \ref{fig:reduced}. This new reduced graph database contains only Web services which are related to both task \emph{input} and task \emph{output}. Applying this procedure to the database chosen in this example reduces the number of Web services in the graph database from 158 to 61.

\begin{figure}[H]
\includegraphics[width=9cm]{Reduced-graph-database.png}
\centering
\caption{Reduced graph database (dataset01, WSC2008)}
\label{fig:reduced} 
\end{figure} 

\section{Generating Web Service Compositions} \label{generatingComp}
Our reduced graph database algorithm allows us to retrieve all the Web service nodes related to a particular task. This section explains how we used related Web service nodes to generate Web service compositions in order to create an initial set of candidates.\par

Algorithm 5 is designed to create feasible compositions. It starts from the end node and searches internal nodes which are directly connected to the end node. Internal nodes are added into the composition list if they fulfill the input of the end node. Then the algorithm recursively goes through each node in the composition list and repeats the above steps until the size of the composition list is stable. This algorithm is also able to calculate the total response time for the creation of each composition,thus determining the total response time from task \emph{input} to task \emph{output}. This total  response time is then used to determine the quality of the solution, when we generate a QoS-Aware service composition. Algorithm 5 calculates the response time during generation of the Web service composition by setting the \emph{duration} property which reflects the time taken from End Node to Start Node. When adding node \emph{N} to the composition list, the algorithm first checks the \emph{druation} property of node \emph{N}. If \emph{N}'s \emph{duration} property value is less than the sum of \emph{N}'s previous node  \emph{duration} property value and  \emph{N}'s execution time ( \emph{N}'s QoS time value), then the algorithm sets  \emph{N}'s \emph{duration} property value to the sum of the  \emph{N}'s previous node \emph{duration} property value and  \emph{N}'s execution time.\par

\begin{algorithm}[H]
 \SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
 \SetKwFunction{connectNode}{connectNode}\SetKwFunction{findCands}{findCands}\SetKwFunction{removeDangling}{removeDangling}
 \LinesNumbered
 \SetNlSty{}{}{:}
   \Input{$endNode$, $relatedNodes$}
 \Output{Web servie composition}
   $i \leftarrow 0$\;
   $relationships \leftarrow \{\}$\;
   $composition \leftarrow \{\}$\; 
   \While{$i < |getIncomingRelationships(endNode)|$}{\label{buildingLine}
       $relationships \leftarrow relationships\cup \{tNode.getIncomingRelationships(endNode)[i]\}$\;
         $i \leftarrow i+1$\;
   }

   $fulfilledNodes \leftarrow fulfilledNodes \cup \{getNodesFulfillCurrentNode(rels)\}$\;
   \If {$| fulfilledNodes | > 0$}{\label{buildingLine}
        $composition \leftarrow composition\cup \{fulfilledNodes\}$\;
      $j \leftarrow 0$\;
      \While{$i < |composition|$}{\label{buildingLine}
        $Recursively Call This Method Until The Size Of FulfillNodes Equals 0$\;
        $j \leftarrow i+1$\;
      }

   }
 \caption{\footnotesize Web services composition algorithm (initial populations).}
\label{generation}
\end{algorithm}

Two examples of Web service composition are shown in Figure \ref{fig:compEg1} and Figure \ref{fig:compEg2} to illustrate the application of our Web service composition algorithm (Algorithm 5) to the reduced graph database we generated in Figure \ref{fig:reduced}. Both compositions show the relationship between task \emph{input} and task \emph{output}. For each node in the composition it is possible to click the Web service node \emph{S} to find the inputs of \emph{S} and also click the incoming edge of \emph{S} to find the input values related to the Web service which lies at the other end of the edge. \par
\begin{figure}[H]
\includegraphics[width=9cm]{web-service-composition-1.png}
\centering
\caption{Web service composition 1 (dataset01, WSC2008)}
\label{fig:compEg1} 
\end{figure} 

\begin{figure}[H]
\includegraphics[width=9cm]{web-service-composition-2.png}
\centering
\caption{Web service composition 2 (dataset01, WSC2008)}
\label{fig:compEg2} 
\end{figure} 

\section{QoS-Aware Service Composition}
In section \ref{generatingComp}, we proposed a Web service composition algorithm. The Web service composition algorithm uses a reduced number of Web services to search for service composition solutions using the smallest number of Web services.\par

The next step of our approach is to select a service composition for a set of solutions, which presents the best QoS for a given task. There are many service compositions which can fulfill the given task. As we can see in section 1, to meet  user's non-functional requirements, we would like to find a service composition that proves the best QoS.

\subsubsection {QoS-Aware Fitness Functions}

To find the best Web service composition from all the candidates generated by our service composition algorithm, a suitable objective function is needed. Objective value reflects the global quality of service of a corresponding service composition. Following the common practice \cite{4,14,19} used in multi-criteria optimization problems, we normalize the values of each QoS property and restrict them to the interval [0,1]. We choose the same objective function as that we used in \cite{4,19} for our approach. The objective function for candidate \emph{i} is defined as follows:
\begin{equation}
objective_{i}=(w_{1} \times A_{i}) + (w_{2} \times R_{i}) + (w_{3} \times T_{i}) + (w_{4} \times C_{i})
\end{equation}

where \emph{A$_{i}$}, \emph{R$_{i}$}, \emph{T$_{i}$} and  \emph{C$_{i}$} denote the normalized availability, reliability,  execution cost and  execution time of candidate \emph{i}, and weights \emph{w} are real positive numbers where $w_{1} + w_{2} + w_{3} + w_{3} = 1$. The value of weights assigned by the user to the objective function represents the importance of the different QoS properties for the Web service composition. \par

Having generated a set of candidates, we then find all the minimum and maximum values for each QoS property. We then use those values to normalize the QoS properties according to the following formula \cite{4}:


\[A_i = \left\{
\begin{array}{l l} 
    \frac{A_i - A_{min}}{A_{max} - A_{min}}      & \quad \mathrm{if } A_{max} - A_{min} \neq 0\\
    1  & \quad \mathrm{if } A_{max} - A_{min} = 0\\
\end{array} \right. \]\label{eq:2}
\[R_i = \left\{
\begin{array}{l l} 
    \frac{R_i - R_{min}}{R_{max} - R_{min}}      & \quad \mathrm{if } R_{max} - R_{min} \neq 0\\
    1  & \quad \mathrm{if } R_{max} - R_{min} = 0\\
\end{array} \right. \]\label{eq:2}
\[T_i = \left\{
\begin{array}{l l} 
    \frac{T_{max} - T_i}{T_{max} - T_{min}}      & \quad \mathrm{if } T_{max} - T_{min} \neq 0\\
    1  & \quad \mathrm{if } T_{max} - T_{min} = 0\\
\end{array} \right. \]\label{eq:2}
\[C_i = \left\{
\begin{array}{l l} 
    \frac{C_{max} - C_i}{C_{max} - C_{min}}      & \quad \mathrm{if } C_{max} - C_{min} \neq 0\\
    1  & \quad \mathrm{if } C_{max} - C_{min} = 0\\
\end{array} \right. \]\label{eq:2}

Once we have found all the minimum and maximum properties, we apply the above normalization functions to calculate the QoS properties for each candidate. Normalized QoS property values close to \emph{1} indicate better quality, while normalized values closer to \emph{0} indicate poorer quality. We then use the normalized QoS properties and weights to calculate the fitness of the individual candidates. Finally, we use the largest fitness value to chose the best Web service composition out of that set of candidates. 